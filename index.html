<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>결제 추이 차트 (엑셀 업로드)</title>

  <!-- SheetJS (xlsx) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e5e7eb; --fg:#111827; --muted:#6b7280;
      --shadow:0 10px 28px rgba(17,24,39,.08);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;background:var(--bg);color:var(--fg)}
    header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid var(--bd)}
    .wrap{max-width:1120px;margin:0 auto;padding:16px}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    .card{background:var(--card);border:1px solid var(--bd);border-radius:var(--radius);box-shadow:var(--shadow)}
    .controls{padding:14px}
    .controls label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    .controls .field{display:flex;gap:10px;align-items:center}
    input[type="file"]{max-width:360px}
    select,input[type="time"],input[type="number"]{
      padding:10px 12px;border:1px solid var(--bd);border-radius:12px;font-size:14px;background:#fff;min-width:160px
    }
    button{padding:10px 14px;border:1px solid var(--bd);border-radius:12px;background:#fff;cursor:pointer}
    button:hover{background:#f3f4f6}
    .hint{font-size:13px;color:var(--muted);margin-top:8px;line-height:1.45}
    .stats{padding:14px;border-top:1px dashed var(--bd);display:flex;flex-wrap:wrap;gap:10px}
    .pill{padding:8px 10px;border:1px solid var(--bd);border-radius:999px;font-size:13px;background:#fff}
    .chart-card{padding:14px;margin-top:12px}
    canvas{width:100% !important;height:520px !important}
    .small{font-size:12px;color:var(--muted)}
    .error{color:#b91c1c;font-weight:700}
    .ok{color:#047857;font-weight:700}
    details{margin-top:10px}
    summary{cursor:pointer;color:var(--muted);font-size:13px}
    pre{white-space:pre-wrap;background:#0b1220;color:#e5e7eb;border-radius:12px;padding:12px;overflow:auto;font-size:12px}
    .chk{display:flex;align-items:center;gap:8px;margin-top:22px}
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="row" style="justify-content:space-between">
      <div>
        <div style="font-weight:800;font-size:18px">결제 내역 추이 (막대 + 곡선)</div>
        <div class="small">✅ 곡선도 “구간별 결제 건수”를 그대로 따라가도록 변경(누적 제거)</div>
      </div>
      <div class="small" id="fileInfo"></div>
    </div>
  </div>
</header>

<main class="wrap">
  <section class="card controls">
    <div class="row">
      <div style="min-width:340px">
        <label>엑셀 파일 업로드 (.xlsx)</label>
        <div class="field">
          <input id="file" type="file" accept=".xlsx,.xls" />
          <button id="demoBtn" type="button">샘플</button>
        </div>
        <div class="hint">
          ✅ “결제일/결제시간” 열을 자동 추정하고 직접 선택도 가능합니다.<br/>
          ✅ 한국어 시간 문자열(오전/오후, 2월11일 12시 등)도 파싱합니다.
        </div>
      </div>

      <div>
        <label>결제시간 열 선택</label>
        <select id="timeCol" disabled></select>
      </div>

      <div>
        <label>집계 단위(분)</label>
        <select id="bin">
          <option value="5">5분</option>
          <option value="10">10분</option>
          <option value="15" selected>15분</option>
          <option value="30">30분</option>
          <option value="60">60분</option>
        </select>
      </div>

      <div>
        <label>시작 시각(첫 결제 날짜 기준)</label>
        <input id="startTime" type="time" value="19:30" step="60" />
      </div>

      <div>
        <label>종료 시각(마지막 결제 날짜 기준)</label>
        <input id="endTime" type="time" value="11:45" step="60" />
      </div>

      <div>
        <label>막대 두께(px)</label>
        <input id="barW" type="number" min="6" max="60" value="24" />
      </div>

      <div class="chk">
        <input id="removeZero" type="checkbox" checked />
        <label for="removeZero" style="margin:0;color:var(--muted);font-size:13px">0건 구간 제거</label>
      </div>

      <div>
        <label>&nbsp;</label>
        <button id="renderBtn" type="button">다시 그리기</button>
      </div>
    </div>

    <div class="stats" id="stats"></div>
    <div class="hint" id="msg"></div>

    <details>
      <summary>디버그 보기(파싱 샘플/실패 샘플)</summary>
      <pre id="debug"></pre>
    </details>
  </section>

  <section class="card chart-card">
    <canvas id="chart"></canvas>
  </section>
</main>

<script>
  // ---------- Utils ----------
  const pad2 = n => String(n).padStart(2,'0');
  const fmtK = d => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  const safeStr = v => (v===null||v===undefined) ? '' : String(v);

  function parseTimeHHMM(hhmm){
    const [h,m] = hhmm.split(':').map(Number);
    return {h, m};
  }
  function setDayTime(date, hhmm){
    const {h,m} = parseTimeHHMM(hhmm);
    const d = new Date(date);
    d.setHours(h, m, 0, 0);
    return d;
  }

  // Excel serial -> Date (fallback)
  function excelDateToJSDate(serial){
    const utcDays = Math.floor(serial - 25569);
    const utcValue = utcDays * 86400;
    const dateInfo = new Date(utcValue * 1000);

    const fractionalDay = serial - Math.floor(serial) + 1e-10;
    let totalSeconds = Math.floor(86400 * fractionalDay);

    const seconds = totalSeconds % 60;
    totalSeconds -= seconds;
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);

    return new Date(dateInfo.getFullYear(), dateInfo.getMonth(), dateInfo.getDate(), hours, minutes, seconds, 0);
  }

  function parseKoreanDateString(s, fallbackYear){
    const raw = safeStr(s).trim();
    if (!raw) return null;

    // "YYYY. M. D. 오전/오후 H:MM:SS"
    let m = raw.match(/^(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(오전|오후)\s*(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if (m){
      const year = Number(m[1]);
      const month = Number(m[2]);
      const day = Number(m[3]);
      const ampm = m[4];
      let hour = Number(m[5]);
      const min = Number(m[6]);
      const sec = Number(m[7] ?? 0);

      if (ampm === '오후' && hour < 12) hour += 12;
      if (ampm === '오전' && hour === 12) hour = 0;

      const d = new Date(year, month-1, day, hour, min, sec, 0);
      return isNaN(d) ? null : d;
    }

    // "M월D일(요일) H시(분)(초)"
    m = raw.match(/^(\d{1,2})\s*월\s*(\d{1,2})\s*일(?:\([^)]*\))?\s*(\d{1,2})\s*시(?:\s*(\d{1,2})\s*분)?(?:\s*(\d{1,2})\s*초)?$/);
    if (m){
      const year = Number(fallbackYear || new Date().getFullYear());
      const month = Number(m[1]);
      const day = Number(m[2]);
      const hour = Number(m[3]);
      const min = Number(m[4] ?? 0);
      const sec = Number(m[5] ?? 0);

      const d = new Date(year, month-1, day, hour, min, sec, 0);
      return isNaN(d) ? null : d;
    }

    return null;
  }

  function normalizeToDate(v, fallbackYear){
    if (v === null || v === undefined || v === '') return null;

    if (v instanceof Date && !isNaN(v)) return v;
    if (typeof v === 'number') return excelDateToJSDate(v);

    if (typeof v === 'string'){
      const kd = parseKoreanDateString(v, fallbackYear);
      if (kd) return kd;

      const d1 = new Date(v);
      if (!isNaN(d1)) return d1;

      const v2 = v.replace(/\./g, '-');
      const d2 = new Date(v2);
      if (!isNaN(d2)) return d2;
    }
    return null;
  }

  // ---------- Binning ----------
  function buildBins(payments, binMinutes, startHHMM, endHHMM, removeZeroBins){
    if (!payments.length) return null;

    let minT = payments[0].getTime();
    let maxT = payments[0].getTime();
    for (const d of payments){
      const t = d.getTime();
      if (t < minT) minT = t;
      if (t > maxT) maxT = t;
    }
    const minD = new Date(minT);
    const maxD = new Date(maxT);

    let start = setDayTime(minD, startHHMM);
    let end   = setDayTime(maxD, endHHMM);
    if (end.getTime() < start.getTime()){
      end = new Date(end.getTime() + 24*3600*1000);
    }

    const stepMs = binMinutes * 60 * 1000;

    let labels = [];
    let edges = [];
    for (let t = start.getTime(); t <= end.getTime(); t += stepMs){
      edges.push(new Date(t));
      labels.push(fmtK(new Date(t)));
    }

    let counts = new Array(edges.length).fill(0);
    let inRange = 0;
    const startT = start.getTime();
    const endT = end.getTime();

    for (const d of payments){
      const tt = d.getTime();
      if (tt < startT || tt > endT) continue;
      inRange++;
      const idx = Math.floor((tt - startT) / stepMs);
      if (idx >= 0 && idx < counts.length) counts[idx] += 1;
    }

    // ✅ 라인도 counts 그대로 쓸 거라 "누적"은 만들지 않음
    let removedZero = 0;
    if (removeZeroBins){
      const keepIdx = [];
      for (let i=0;i<counts.length;i++){
        if (counts[i] > 0) keepIdx.push(i);
        else removedZero++;
      }

      if (keepIdx.length > 0){
        const newLabels = [];
        const newEdges = [];
        const newCounts = [];
        for (const i of keepIdx){
          newLabels.push(labels[i]);
          newEdges.push(edges[i]);
          newCounts.push(counts[i]);
        }
        labels = newLabels;
        edges = newEdges;
        counts = newCounts;
      }
    }

    return {start, end, minD, maxD, labels, edges, counts, inRange, removedZero};
  }

  // ---------- Chart ----------
  let chart = null;

  function renderChart(model, barThickness){
    const ctx = document.getElementById('chart');
    if (chart) chart.destroy();

    const {labels, counts, edges} = model;
    const stepMs = edges.length >= 2 ? (edges[1].getTime() - edges[0].getTime()) : 0;
    const barW = Math.max(6, Math.min(60, Number(barThickness) || 24));

    chart = new Chart(ctx, {
      data: {
        labels,
        datasets: [
          {
            type:'bar',
            label:'구간별 결제 건수(막대)',
            data: counts,
            borderWidth: 1,
            barThickness: barW,
            maxBarThickness: Math.min(70, barW + 14),
            categoryPercentage: 0.9,
            barPercentage: 0.95
          },
          {
            type:'line',
            label:'구간별 결제 건수(곡선)',
            data: counts,
            tension:0.35,
            pointRadius:0,
            borderWidth:2
          }
        ]
      },
      options: {
        responsive:true,
        maintainAspectRatio:false,
        interaction:{ mode:'index', intersect:false },
        plugins:{
          tooltip:{
            callbacks:{
              title:(items)=>{
                const i = items?.[0]?.dataIndex ?? 0;
                const t0 = edges[i];
                const t1 = new Date(t0.getTime() + stepMs);
                return `${fmtK(t0)} ~ ${fmtK(t1)}`;
              },
              label:(item)=>{
                return `${item.dataset.label}: ${item.formattedValue}건`;
              }
            }
          },
          legend:{ position:'top' }
        },
        scales:{
          x:{
            ticks:{
              maxRotation:0,
              autoSkip:true,
              maxTicksLimit: 24
            }
          },
          y:{ beginAtZero:true, title:{ display:true, text:'구간 결제 건수' } }
        }
      }
    });

    const stats = document.getElementById('stats');
    stats.innerHTML = `
      <div class="pill"><b>자동 집계 구간</b>: ${fmtK(model.start)} ~ ${fmtK(model.end)}</div>
      <div class="pill"><b>데이터 최소/최대</b>: ${fmtK(model.minD)} ~ ${fmtK(model.maxD)}</div>
      <div class="pill"><b>구간 내 결제(집계됨)</b>: ${model.inRange}건</div>
      <div class="pill"><b>총 결제(파싱 성공)</b>: ${model.totalParsed}건</div>
      <div class="pill"><b>파싱 실패</b>: ${model.parseFail}건</div>
      <div class="pill"><b>원본 행 수(헤더 제외)</b>: ${model.totalRows}행</div>
      <div class="pill"><b>표시 구간 수</b>: ${model.labels.length}개</div>
      <div class="pill"><b>제거된 0건 구간</b>: ${model.removedZero}개</div>
    `;
  }

  // ---------- Read Excel ----------
  let header = [];
  let dataRows = [];

  function guessTimeColIndex(headerRow){
    const keys = ['결제', '결제일', '결제시간', '승인', '승인시간', '시간', '일시', '거래일시', '거래시간', 'datetime', 'timestamp'];
    let bestIdx = 0, bestScore = -1;

    for (let i=0;i<headerRow.length;i++){
      const h = safeStr(headerRow[i]).toLowerCase().trim();
      if (!h) continue;
      let score = 0;
      for (const k of keys){
        if (h.includes(k.toLowerCase())) score += 10;
      }
      if (h.includes('date') || h.includes('time')) score += 3;
      if (score > bestScore){
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function buildColSelect(headerRow, selectedIdx){
    const sel = document.getElementById('timeCol');
    sel.innerHTML = '';
    headerRow.forEach((h, i)=>{
      const opt = document.createElement('option');
      const name = safeStr(h).trim() || `(빈 헤더 ${i+1}열)`;
      opt.value = String(i);
      opt.textContent = `${i+1}열: ${name}`;
      sel.appendChild(opt);
    });
    sel.value = String(selectedIdx);
    sel.disabled = false;
  }

  function detectFallbackYear(colIdx){
    for (let r=0; r<dataRows.length; r++){
      const v = dataRows[r]?.[colIdx];
      if (v instanceof Date && !isNaN(v)) return v.getFullYear();
      if (typeof v === 'string'){
        const m = v.trim().match(/^(\d{4})\./);
        if (m) return Number(m[1]);
      }
    }
    return new Date().getFullYear();
  }

  function parsePaymentsFromRows(colIdx){
    const fallbackYear = detectFallbackYear(colIdx);
    const payments = [];
    const fail = [];

    for (let r=0; r<dataRows.length; r++){
      const v = dataRows[r]?.[colIdx];
      const d = normalizeToDate(v, fallbackYear);
      if (d) payments.push(d);
      else if (safeStr(v).trim() !== '') fail.push({row: r+2, value: v});
    }

    return {payments, fail, fallbackYear};
  }

  function rebuild(){
    const msg = document.getElementById('msg');
    msg.textContent = '';

    if (!dataRows.length){
      msg.innerHTML = `<span class="error">엑셀을 먼저 업로드해주세요.</span>`;
      return;
    }

    const binMinutes = Number(document.getElementById('bin').value);
    const startHHMM = document.getElementById('startTime').value || '19:30';
    const endHHMM   = document.getElementById('endTime').value || '11:45';
    const colIdx = Number(document.getElementById('timeCol').value || '0');
    const removeZeroBins = document.getElementById('removeZero').checked;
    const barW = Number(document.getElementById('barW').value || 24);

    const {payments, fail, fallbackYear} = parsePaymentsFromRows(colIdx);

    // 디버그
    const debug = document.getElementById('debug');
    const okSample = payments.slice(0, 30).map(d=>fmtK(d)).join('\n');
    const failSample = fail.slice(0, 20).map(x=>`row ${x.row}: ${safeStr(x.value)}`).join('\n');
    debug.textContent =
      `선택한 열: ${colIdx+1}열 / "${safeStr(header[colIdx]).trim()}"\n` +
      `추정 연도(fallbackYear): ${fallbackYear}\n` +
      `파싱 성공: ${payments.length}건\n파싱 실패: ${fail.length}건\n\n` +
      `--- 파싱 성공 샘플(30개) ---\n${okSample}\n\n` +
      `--- 파싱 실패 샘플(최대 20개) ---\n${failSample || '(없음)'}\n`;

    if (!payments.length){
      msg.innerHTML = `<span class="error">선택한 열에서 결제시간을 1건도 파싱 못 했어요. (열 선택/서식 확인)</span>`;
      return;
    }

    const model = buildBins(payments, binMinutes, startHHMM, endHHMM, removeZeroBins);
    if (!model){
      msg.innerHTML = `<span class="error">차트 모델 생성 실패</span>`;
      return;
    }

    model.totalParsed = payments.length;
    model.parseFail = fail.length;
    model.totalRows = dataRows.length;

    renderChart(model, barW);

    const note = removeZeroBins
      ? `0건 구간 제거 ON → 결제 발생한 구간만 표시`
      : `0건 구간 제거 OFF → 전체 시간대 표시`;

    msg.innerHTML = (fail.length === 0)
      ? `<span class="ok">OK</span> ${note}`
      : `<span class="error">주의</span> 파싱 실패 ${fail.length}건 존재. (디버그 보기에서 실패 샘플 확인) / ${note}`;
  }

  document.getElementById('file').addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    document.getElementById('fileInfo').textContent = `선택됨: ${file.name}`;
    const msg = document.getElementById('msg');
    msg.textContent = '읽는 중...';

    try{
      const data = new Uint8Array(await file.arrayBuffer());
      const wb = XLSX.read(data, {type:'array', cellDates:true});
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];

      const rows = XLSX.utils.sheet_to_json(ws, {header:1, raw:true, defval:''});
      header = rows[0] || [];
      dataRows = rows.slice(1);

      const guessed = guessTimeColIndex(header);
      buildColSelect(header, guessed);

      msg.textContent = `완료! (시트: ${sheetName}, 원본 데이터 ${dataRows.length}행)`;
      rebuild();
    } catch(err){
      console.error(err);
      msg.innerHTML = `<span class="error">엑셀 읽기 실패: ${String(err)}</span>`;
    }
  });

  document.getElementById('renderBtn').addEventListener('click', rebuild);
  document.getElementById('bin').addEventListener('change', rebuild);
  document.getElementById('startTime').addEventListener('change', rebuild);
  document.getElementById('endTime').addEventListener('change', rebuild);
  document.getElementById('timeCol').addEventListener('change', rebuild);
  document.getElementById('removeZero').addEventListener('change', rebuild);
  document.getElementById('barW').addEventListener('input', rebuild);

  // 샘플 데이터(중복 시간 포함)
  document.getElementById('demoBtn').addEventListener('click', () => {
    header = ['결제시간', '기타'];
    dataRows = [];

    const base = new Date();
    base.setDate(base.getDate()-2);
    base.setHours(19,30,0,0);

    // 같은 시간대에 몰아넣기(중복)
    for (let i=0;i<60;i++){
      dataRows.push([new Date(base.getTime() + (i%3)*60*1000), 'dup']); // 3분 안에 몰림
    }
    // 랜덤
    for (let i=0;i<140;i++){
      const jitter = Math.floor(Math.random()* (40*60*60*1000));
      dataRows.push([new Date(base.getTime()+jitter), 'rnd']);
    }

    buildColSelect(header, 0);
    document.getElementById('fileInfo').textContent = '샘플 데이터 사용 중';
    document.getElementById('msg').textContent = `샘플 완료! (${dataRows.length}행)`;
    rebuild();
  });
</script>
</body>
</html>
